/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktodo_list_webpack"] = self["webpackChunktodo_list_webpack"] || []).push([["src_weather-app_js"],{

/***/ "./src/images/bg lazy recursive ^\\.\\/.*\\.jpg$ referencedExports: , default":
/*!*****************************************************************************************!*\
  !*** ./src/images/bg/ lazy ^\.\/.*\.jpg$ referencedExports: , default namespace object ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./clear-day.jpg": [
		"./src/images/bg/clear-day.jpg",
		"src_images_bg_clear-day_jpg"
	],
	"./clear-night.jpg": [
		"./src/images/bg/clear-night.jpg",
		"src_images_bg_clear-night_jpg"
	],
	"./cloudy.jpg": [
		"./src/images/bg/cloudy.jpg",
		"src_images_bg_cloudy_jpg"
	],
	"./fog-2.jpg": [
		"./src/images/bg/fog-2.jpg",
		"src_images_bg_fog-2_jpg"
	],
	"./fog.jpg": [
		"./src/images/bg/fog.jpg",
		"src_images_bg_fog_jpg"
	],
	"./mostly-sunny.jpg": [
		"./src/images/bg/mostly-sunny.jpg",
		"src_images_bg_mostly-sunny_jpg"
	],
	"./partly-cloudy-day.jpg": [
		"./src/images/bg/partly-cloudy-day.jpg",
		"src_images_bg_partly-cloudy-day_jpg"
	],
	"./partly-cloudy-night.jpg": [
		"./src/images/bg/partly-cloudy-night.jpg",
		"src_images_bg_partly-cloudy-night_jpg"
	],
	"./rain-2.jpg": [
		"./src/images/bg/rain-2.jpg",
		"src_images_bg_rain-2_jpg"
	],
	"./rain.jpg": [
		"./src/images/bg/rain.jpg",
		"src_images_bg_rain_jpg"
	],
	"./snow shower2.jpg": [
		"./src/images/bg/snow shower2.jpg",
		"src_images_bg_snow_shower2_jpg"
	],
	"./snow shower4.jpg": [
		"./src/images/bg/snow shower4.jpg",
		"src_images_bg_snow_shower4_jpg"
	],
	"./snow-showers-day.jpg": [
		"./src/images/bg/snow-showers-day.jpg",
		"src_images_bg_snow-showers-day_jpg"
	],
	"./snow-showers-night.jpg": [
		"./src/images/bg/snow-showers-night.jpg",
		"src_images_bg_snow-showers-night_jpg"
	],
	"./snow.jpg": [
		"./src/images/bg/snow.jpg",
		"src_images_bg_snow_jpg"
	],
	"./sunny.jpg": [
		"./src/images/bg/sunny.jpg",
		"src_images_bg_sunny_jpg"
	],
	"./thunder.jpg": [
		"./src/images/bg/thunder.jpg",
		"src_images_bg_thunder_jpg"
	],
	"./wind.jpg": [
		"./src/images/bg/wind.jpg",
		"src_images_bg_wind_jpg"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__.t(id, 1 | 16);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./src/images/bg lazy recursive ^\\.\\/.*\\.jpg$ referencedExports: , default";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/images/icons lazy recursive ^\\.\\/.*\\.png$":
/*!***************************************************************!*\
  !*** ./src/images/icons/ lazy ^\.\/.*\.png$ namespace object ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./fog.png": [
		"./src/images/icons/fog.png",
		"src_images_icons_fog_png"
	],
	"./thunder.png": [
		"./src/images/icons/thunder.png",
		"src_images_icons_thunder_png"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__.t(id, 1 | 16);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./src/images/icons lazy recursive ^\\.\\/.*\\.png$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/images/icons lazy recursive ^\\.\\/.*\\.svg$":
/*!***************************************************************!*\
  !*** ./src/images/icons/ lazy ^\.\/.*\.svg$ namespace object ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./MostlySunnyDay.svg": [
		"./src/images/icons/MostlySunnyDay.svg",
		"src_images_icons_MostlySunnyDay_svg"
	],
	"./clear-day.svg": [
		"./src/images/icons/clear-day.svg",
		"src_images_icons_clear-day_svg"
	],
	"./clear-night.svg": [
		"./src/images/icons/clear-night.svg",
		"src_images_icons_clear-night_svg"
	],
	"./cloudy.svg": [
		"./src/images/icons/cloudy.svg",
		"src_images_icons_cloudy_svg"
	],
	"./partly-cloudy-day.svg": [
		"./src/images/icons/partly-cloudy-day.svg",
		"src_images_icons_partly-cloudy-day_svg"
	],
	"./partly-cloudy-night.svg": [
		"./src/images/icons/partly-cloudy-night.svg",
		"src_images_icons_partly-cloudy-night_svg"
	],
	"./rain.svg": [
		"./src/images/icons/rain.svg",
		"src_images_icons_rain_svg"
	],
	"./snow-showers-day.svg": [
		"./src/images/icons/snow-showers-day.svg",
		"src_images_icons_snow-showers-day_svg"
	],
	"./snow-showers-night.svg": [
		"./src/images/icons/snow-showers-night.svg",
		"src_images_icons_snow-showers-night_svg"
	],
	"./snow.svg": [
		"./src/images/icons/snow.svg",
		"src_images_icons_snow_svg"
	],
	"./sunny.svg": [
		"./src/images/icons/sunny.svg",
		"src_images_icons_sunny_svg"
	],
	"./wind.svg": [
		"./src/images/icons/wind.svg",
		"src_images_icons_wind_svg"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__.t(id, 1 | 16);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./src/images/icons lazy recursive ^\\.\\/.*\\.svg$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./src/weather-app.js":
/*!****************************!*\
  !*** ./src/weather-app.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{const clog = console.log\n\n\n/// Code\n\n\nif (true) { console.log('Looks like we are in development mode!') }\n\n// Code\n\nconst dateNow = new Date()\nconst dateNowHours = dateNow.getUTCHours()\nconst dateNowDay = dateNow.getUTCDay()\nconst dayArray = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\nconst getDayString = function(){\n    return dayArray[dateNowDay]\n}\n\nclog(dateNowDay)\nclog(getDayString())\n\nconst getRawWeatherData = async function(location = \"london\") {\n    skeletonLoadingBegins()\n    const serverBaseUrl = \"https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline\"\n    const apiKey = \"7SZB422JF2656H4U2T3XMFNE5\"\n    const url = `${serverBaseUrl}/${location}?key=${apiKey}`\n    \n    try {\n    const rawWeatherData = await fetch( url )\n    const weatherData = await rawWeatherData.json()\n    skeletonLoadingEnds()\n    return weatherData\n\n    } catch(error) {clog(error)}\n\n}\n\nconst weatherToday = async function(location, selectedMetric) {\n    let weatherData = await getRawWeatherData(location, selectedMetric)\n    clog(\"ðŸ”” Raw weatherData below: \")\n    clog(weatherData)\n    let data = weatherData.days[0]\n    let icon = weatherData.days[0].icon\n    let description = weatherData.days[0].description\n    let dayConditions = weatherData.days[0].hours[dateNowHours]\n    let address = weatherData.address\n    let data15Days = weatherData.days\n    clog(dayConditions)\n    return {data, icon, description, dayConditions, address, data15Days }\n}\n// clog( weatherToday(\"paris\").then(msg => { clog(msg.description) }) )\n\nconst weatherNextComingDays = async function(days = 7, location, selectedMetric ) {\n    let weatherData = await getRawWeatherData(location, selectedMetric)\n    clog(\"ðŸ”” Raw weatherData below: \")\n    clog(weatherData)\n    let tempArray = []\n    let nextComingDaysData = \"\"\n    if(days > 15 || days < 1) {\n        alert(\"ðŸ”” Forecast data only available for the next 15 days.\")\n        return\n    }\n    else {\n        for (let i = 1; i <= days; i++) { tempArray.push( weatherData.days[i] ) }\n        tempArray\n        nextComingDaysData = tempArray\n        clog(`ðŸ”” Next coming days weather data array is:`)\n        clog(nextComingDaysData)\n    }\n\n    return nextComingDaysData\n}\n\n// weatherToday(\"paris\").then(msg => { clog(msg.description) })\n\n/// DOM manipulation\n\n// Function to start skeleton loading by adding \"skeleton\" classes to group\n// Skeleton are always enabled  on page load by default at css (animation)\n\nfunction skeletonLoadingBegins() {\n    \n    const allLoadingDivBg = document.querySelectorAll(\".container-top, .div-right, .container-body \")\n    const allLoadingDiv = document.querySelectorAll(\".div-left\")\n\n    allLoadingDivBg.forEach(i => {\n        i.classList.add(\"loading-div-bg\")\n    })\n\n    allLoadingDiv.forEach(i => {\n        i.classList.add(\"loading-div\")\n    })\n}\n\n// Function to stop skeleton loading by removing \"skeleton\" classes from group\n\n function skeletonLoadingEnds() {\n    // grouping divs by classes\n    const allLoadingDivBg = document.querySelectorAll(\".container-top, .div-right, .container-body \")\n    const allLoadingDiv = document.querySelectorAll(\".div-left\")\n\n    allLoadingDivBg.forEach(i => {\n        i.classList.remove(\"loading-div-bg\")\n    })\n\n    allLoadingDiv.forEach(i => {\n        i.classList.remove(\"loading-div\")\n    })\n}\n\n// Will disable skeleton only if weather data become available\n\n\n// Data conversion\n\nconst tempButton = document.querySelector(\".weather-temp-intro button\")\nconst tempDegSymbolDiv = document.querySelector(\".weather-temp-div .temp-deg-symbol\")\n\nlet currentMetric = \"intl\"\n\nfunction toCelsius(f) {\n    return (f - 32) * 5/9\n}\n\nfunction toFahrenheit(c) {\n    return (c * 9/5) + 32\n}\n\nfunction toMph(kmh) {\n    return kmh / 1.609\n}\n\nfunction toKmh(mph) {\n    return mph * 1.609\n}\n\ntempButton.addEventListener(\"click\", () => {\n    toggleMetric()\n})\n\n// let strTest = \"Wind: 10.8 mph\" \n// clog(strTest.slice(5).slice(0, -4))\n\n\n// Event listeners\n\nfunction toggleMetric() {\n    const tempNumberDiv = document.querySelector(\".weather-temp-div .temp-number\")\n    const windSpeedDiv = document.querySelector(\".weather-info-div .info3\")\n    \n    let degNumber = Number(tempNumberDiv.textContent)\n    clog(`ðŸš¨ CurrentMetric = ${currentMetric}`)\n    if (currentMetric === \"us\") {\n        tempButton.textContent = \"Â°C\"\n        tempDegSymbolDiv.textContent = \"Â°C\"\n        tempNumberDiv.textContent = toCelsius(degNumber).toFixed(0)\n        let windSpeed = Number( `${windSpeedDiv.textContent.slice(6).slice(0, -4)} ` )\n        windSpeedDiv.textContent = `Wind: ${ toKmh(windSpeed).toFixed(1) } km/h` \n        clog(`ðŸ”” extracted windSpeed number is: ${windSpeed}` )\n        currentMetric = \"intl\"\n        clog(\"ðŸ”” Converted to international format (Celsius & kmh).\")\n    }\n    else if(currentMetric === \"intl\") {\n        tempButton.textContent = \"Â°F\"\n        tempDegSymbolDiv.textContent = \"Â°F\"\n        tempNumberDiv.textContent = toFahrenheit(degNumber).toFixed(0)\n        let windSpeed = Number( `${windSpeedDiv.textContent.slice(6).slice(0, -5)} ` )\n        windSpeedDiv.textContent = `Wind: ${ toMph(windSpeed).toFixed(1) } mph` \n        currentMetric = \"us\"\n        clog(\"ðŸ”” Converted to us format (Fahrenheit & mph).\")\n    }\n    \n}\n\n\nconst populateDisplay = async function(searchedLocation, selectedMetric){\n    if (!searchedLocation) {\n        clog(\"ðŸ”” No search term provided!\")\n        return\n    }\n    else {\n        const cityDiv = document.querySelector(\".div-right .weather-title\")\n        const descriptionDiv = document.querySelector(\".div-right .weather-description\")\n        const dateDiv = document.querySelector(\".div-right .weather-date\")\n        const tempDegDiv = document.querySelector(\".div-left .temp-number\")\n        const tempDegSymbolDiv = document.querySelector(\".div-left .temp-deg-symbol\")\n        const tempDegBtnDiv = document.querySelector(\".weather-temp-intro button\")\n        const info1Div = document.querySelector(\".div-left .info1\")\n        const info2Div = document.querySelector(\".div-left .info2\")\n        const info3Div = document.querySelector(\".div-left .info3\")\n        \n        let responseData = await weatherToday(searchedLocation)\n\n        const getWeatherIcon = async function() {\n            let fileName = responseData.dayConditions.icon \n            if(fileName === \"fog\" || fileName === \"thunder\" ){\n                fileName = await __webpack_require__(\"./src/images/icons lazy recursive ^\\\\.\\\\/.*\\\\.png$\")(`./${fileName}.png`)\n                return {fileName}\n            }\n            else { \n                fileName = await __webpack_require__(\"./src/images/icons lazy recursive ^\\\\.\\\\/.*\\\\.svg$\")(`./${fileName}.svg`)\n                return {fileName} }\n        }\n        \n        await getWeatherIcon().then(msg => clog(msg.fileName.default))\n        const weatherIconDiv = document.querySelector(\".weather-now-div .weather-now-icon\")\n        const weatherIconPath = await getWeatherIcon().then(msg => msg.fileName.default)\n        weatherIconDiv.setAttribute(\"src\", `${weatherIconPath}`)\n\n        let city = responseData.address\n        let description = responseData.description\n        let degUsFormat = responseData.dayConditions.temp.toFixed(0)\n        let windSpeedUsFormat = responseData.dayConditions.windspeed.toFixed(1)\n        let precipitation = responseData.dayConditions.precipprob\n        let humidity = responseData.dayConditions.humidity\n        // Converting data based on user settings\n        let tempDeg\n        let windSpeed\n        if (currentMetric === \"intl\") {\n            clog(\"ðŸ”” Pre-converting data to intl format\")\n            tempDeg = toCelsius(degUsFormat).toFixed(0)\n            windSpeed =  toKmh(windSpeedUsFormat).toFixed(1)\n            tempDegSymbolDiv.textContent = \"Â°C\"\n            tempDegBtnDiv.textContent = \"Â°C\"\n            info3Div.textContent = `Wind: ${windSpeed} km/h`\n        } \n        else if (currentMetric === \"us\") {\n            clog(\"ðŸ”” Pre-converting data to us format\")\n            clog(degUsFormat)\n            tempDeg = degUsFormat\n            windSpeed = windSpeedUsFormat\n            tempDegSymbolDiv.textContent = \"Â°F\"\n            tempDegBtnDiv.textContent = \"Â°F\"\n            info3Div.textContent = `Wind: ${windSpeed} mph`\n        }\n        \n        cityDiv.textContent = city.slice(0, 1).toUpperCase() + city.slice(1)\n        descriptionDiv.textContent = description\n        dateDiv.textContent = `${getDayString()} ${dateNowHours}:00`\n        tempDegDiv.textContent = tempDeg\n        info1Div.textContent = `Precipitation: ${precipitation}%`\n        info2Div.textContent = `Humidity: ${humidity}%` \n        \n        // Dynamic Background-images\n        const backgroundDiv = document.querySelector(\"body\")\n        let bgImage = await __webpack_require__(\"./src/images/bg lazy recursive ^\\\\.\\\\/.*\\\\.jpg$ referencedExports: , default\")(`./${responseData.dayConditions.icon}.jpg`)\n        clog(bgImage)\n        const bgImageFile = bgImage.default\n        backgroundDiv.style.cssText = `background-image: url(\"${bgImageFile}\");`\n        clog(backgroundDiv.style.backgroundImage)\n\n        /// Bottom cards\n\n        // Looping days using \"for ... loop\" below\n        // Will be incrementing \"base\" date by \n        // twentyFourHours (24h = 8.64e+7ms) each iteration \n\n        let twentyFourHours = 0\n        for (let i = 1; i <= 8; i++) {\n            twentyFourHours += 8.64e+7\n\n            // subtracting 24h (in milliseconds) (from \"base\") helps starts \n            // iterating from today's date\n            let base = Date.now() - 8.64e+7\n\n            // Now ready to start incrementing.\n            let currentDate = base + twentyFourHours\n            let currentDateDay = new Date(currentDate).getDay()\n            clog(currentDateDay)\n            // Indexing div element by ids based on current (i) index\n            const cardDayDiv = document.querySelector(`#weather-card${i} .day`)\n            const cardIconDiv = document.querySelector(`#weather-card${i} .icon`)\n            const cardTempDiv = document.querySelector(`#weather-card${i} .temp`)\n\n            // Giving day title & temp data to div element based on \"currentDateDay\"\n            // currentDateDay will returns successive date each iteration)\n            // Each date corresponds to one of the 7 days of the week.\n            cardDayDiv.textContent = `${dayArray[currentDateDay]}`\n            cardTempDiv.textContent = `${responseData.data15Days[i-1].temp}Â°F`\n\n            const getNextDayIcon = async function() {\n                let fileName = responseData.data15Days[i-1].icon \n                if(fileName === \"fog\" || fileName === \"thunder\" ){\n                    fileName = await __webpack_require__(\"./src/images/icons lazy recursive ^\\\\.\\\\/.*\\\\.png$\")(`./${fileName}.png`)\n                    return fileName\n                }\n                else { \n                    fileName = await __webpack_require__(\"./src/images/icons lazy recursive ^\\\\.\\\\/.*\\\\.svg$\")(`./${fileName}.svg`)\n                    return fileName\n                }\n            }\n            const nextDayIconPath = await getNextDayIcon().then(msg => msg.default)\n            cardIconDiv.setAttribute(\"src\", `${nextDayIconPath}` ) \n        }\n    }\n}\n\n\n// Search functionalities\n\nconst searchInput = document.querySelector(\"label input\")\nconst searchBtn = document.querySelector(\"label button\")\n\nsearchBtn.addEventListener(\"click\", (e) => {\n    if (searchInput.value){\n        e.preventDefault()\n        populateDisplay(searchInput.value)\n    }\n    else {\n        searchInput.reportValidity()\n        if (!searchInput.validity.valid){\n          searchInput.setCustomValidity(\"Please enter a city to get forecast\") \n        }\n    }\n})\n\n// Loading page by default with live weather data\npopulateDisplay(\"tokyo\") \n// skeletonLoadingEnds()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LHlDQUF5QyxrQ0FBa0M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwRUFBTyxHQUFnQixFQUFFLFNBQVMsS0FBSyxDQUFDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwRUFBTyxHQUFnQixFQUFFLFNBQVMsS0FBSyxDQUFDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0LXdlYnBhY2svLi9zcmMvd2VhdGhlci1hcHAuanM/N2ZkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjbG9nID0gY29uc29sZS5sb2dcblxuXG4vLy8gQ29kZVxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7IGNvbnNvbGUubG9nKCdMb29rcyBsaWtlIHdlIGFyZSBpbiBkZXZlbG9wbWVudCBtb2RlIScpIH1cblxuLy8gQ29kZVxuXG5jb25zdCBkYXRlTm93ID0gbmV3IERhdGUoKVxuY29uc3QgZGF0ZU5vd0hvdXJzID0gZGF0ZU5vdy5nZXRVVENIb3VycygpXG5jb25zdCBkYXRlTm93RGF5ID0gZGF0ZU5vdy5nZXRVVENEYXkoKVxuY29uc3QgZGF5QXJyYXkgPSBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXVxuY29uc3QgZ2V0RGF5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZGF5QXJyYXlbZGF0ZU5vd0RheV1cbn1cblxuY2xvZyhkYXRlTm93RGF5KVxuY2xvZyhnZXREYXlTdHJpbmcoKSlcblxuY29uc3QgZ2V0UmF3V2VhdGhlckRhdGEgPSBhc3luYyBmdW5jdGlvbihsb2NhdGlvbiA9IFwibG9uZG9uXCIpIHtcbiAgICBza2VsZXRvbkxvYWRpbmdCZWdpbnMoKVxuICAgIGNvbnN0IHNlcnZlckJhc2VVcmwgPSBcImh0dHBzOi8vd2VhdGhlci52aXN1YWxjcm9zc2luZy5jb20vVmlzdWFsQ3Jvc3NpbmdXZWJTZXJ2aWNlcy9yZXN0L3NlcnZpY2VzL3RpbWVsaW5lXCJcbiAgICBjb25zdCBhcGlLZXkgPSBcIjdTWkI0MjJKRjI2NTZINFUyVDNYTUZORTVcIlxuICAgIGNvbnN0IHVybCA9IGAke3NlcnZlckJhc2VVcmx9LyR7bG9jYXRpb259P2tleT0ke2FwaUtleX1gXG4gICAgXG4gICAgdHJ5IHtcbiAgICBjb25zdCByYXdXZWF0aGVyRGF0YSA9IGF3YWl0IGZldGNoKCB1cmwgKVxuICAgIGNvbnN0IHdlYXRoZXJEYXRhID0gYXdhaXQgcmF3V2VhdGhlckRhdGEuanNvbigpXG4gICAgc2tlbGV0b25Mb2FkaW5nRW5kcygpXG4gICAgcmV0dXJuIHdlYXRoZXJEYXRhXG5cbiAgICB9IGNhdGNoKGVycm9yKSB7Y2xvZyhlcnJvcil9XG5cbn1cblxuY29uc3Qgd2VhdGhlclRvZGF5ID0gYXN5bmMgZnVuY3Rpb24obG9jYXRpb24sIHNlbGVjdGVkTWV0cmljKSB7XG4gICAgbGV0IHdlYXRoZXJEYXRhID0gYXdhaXQgZ2V0UmF3V2VhdGhlckRhdGEobG9jYXRpb24sIHNlbGVjdGVkTWV0cmljKVxuICAgIGNsb2coXCLwn5SUIFJhdyB3ZWF0aGVyRGF0YSBiZWxvdzogXCIpXG4gICAgY2xvZyh3ZWF0aGVyRGF0YSlcbiAgICBsZXQgZGF0YSA9IHdlYXRoZXJEYXRhLmRheXNbMF1cbiAgICBsZXQgaWNvbiA9IHdlYXRoZXJEYXRhLmRheXNbMF0uaWNvblxuICAgIGxldCBkZXNjcmlwdGlvbiA9IHdlYXRoZXJEYXRhLmRheXNbMF0uZGVzY3JpcHRpb25cbiAgICBsZXQgZGF5Q29uZGl0aW9ucyA9IHdlYXRoZXJEYXRhLmRheXNbMF0uaG91cnNbZGF0ZU5vd0hvdXJzXVxuICAgIGxldCBhZGRyZXNzID0gd2VhdGhlckRhdGEuYWRkcmVzc1xuICAgIGxldCBkYXRhMTVEYXlzID0gd2VhdGhlckRhdGEuZGF5c1xuICAgIGNsb2coZGF5Q29uZGl0aW9ucylcbiAgICByZXR1cm4ge2RhdGEsIGljb24sIGRlc2NyaXB0aW9uLCBkYXlDb25kaXRpb25zLCBhZGRyZXNzLCBkYXRhMTVEYXlzIH1cbn1cbi8vIGNsb2coIHdlYXRoZXJUb2RheShcInBhcmlzXCIpLnRoZW4obXNnID0+IHsgY2xvZyhtc2cuZGVzY3JpcHRpb24pIH0pIClcblxuY29uc3Qgd2VhdGhlck5leHRDb21pbmdEYXlzID0gYXN5bmMgZnVuY3Rpb24oZGF5cyA9IDcsIGxvY2F0aW9uLCBzZWxlY3RlZE1ldHJpYyApIHtcbiAgICBsZXQgd2VhdGhlckRhdGEgPSBhd2FpdCBnZXRSYXdXZWF0aGVyRGF0YShsb2NhdGlvbiwgc2VsZWN0ZWRNZXRyaWMpXG4gICAgY2xvZyhcIvCflJQgUmF3IHdlYXRoZXJEYXRhIGJlbG93OiBcIilcbiAgICBjbG9nKHdlYXRoZXJEYXRhKVxuICAgIGxldCB0ZW1wQXJyYXkgPSBbXVxuICAgIGxldCBuZXh0Q29taW5nRGF5c0RhdGEgPSBcIlwiXG4gICAgaWYoZGF5cyA+IDE1IHx8IGRheXMgPCAxKSB7XG4gICAgICAgIGFsZXJ0KFwi8J+UlCBGb3JlY2FzdCBkYXRhIG9ubHkgYXZhaWxhYmxlIGZvciB0aGUgbmV4dCAxNSBkYXlzLlwiKVxuICAgICAgICByZXR1cm5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGRheXM7IGkrKykgeyB0ZW1wQXJyYXkucHVzaCggd2VhdGhlckRhdGEuZGF5c1tpXSApIH1cbiAgICAgICAgdGVtcEFycmF5XG4gICAgICAgIG5leHRDb21pbmdEYXlzRGF0YSA9IHRlbXBBcnJheVxuICAgICAgICBjbG9nKGDwn5SUIE5leHQgY29taW5nIGRheXMgd2VhdGhlciBkYXRhIGFycmF5IGlzOmApXG4gICAgICAgIGNsb2cobmV4dENvbWluZ0RheXNEYXRhKVxuICAgIH1cblxuICAgIHJldHVybiBuZXh0Q29taW5nRGF5c0RhdGFcbn1cblxuLy8gd2VhdGhlclRvZGF5KFwicGFyaXNcIikudGhlbihtc2cgPT4geyBjbG9nKG1zZy5kZXNjcmlwdGlvbikgfSlcblxuLy8vIERPTSBtYW5pcHVsYXRpb25cblxuLy8gRnVuY3Rpb24gdG8gc3RhcnQgc2tlbGV0b24gbG9hZGluZyBieSBhZGRpbmcgXCJza2VsZXRvblwiIGNsYXNzZXMgdG8gZ3JvdXBcbi8vIFNrZWxldG9uIGFyZSBhbHdheXMgZW5hYmxlZCAgb24gcGFnZSBsb2FkIGJ5IGRlZmF1bHQgYXQgY3NzIChhbmltYXRpb24pXG5cbmZ1bmN0aW9uIHNrZWxldG9uTG9hZGluZ0JlZ2lucygpIHtcbiAgICBcbiAgICBjb25zdCBhbGxMb2FkaW5nRGl2QmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNvbnRhaW5lci10b3AsIC5kaXYtcmlnaHQsIC5jb250YWluZXItYm9keSBcIilcbiAgICBjb25zdCBhbGxMb2FkaW5nRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5kaXYtbGVmdFwiKVxuXG4gICAgYWxsTG9hZGluZ0RpdkJnLmZvckVhY2goaSA9PiB7XG4gICAgICAgIGkuY2xhc3NMaXN0LmFkZChcImxvYWRpbmctZGl2LWJnXCIpXG4gICAgfSlcblxuICAgIGFsbExvYWRpbmdEaXYuZm9yRWFjaChpID0+IHtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKFwibG9hZGluZy1kaXZcIilcbiAgICB9KVxufVxuXG4vLyBGdW5jdGlvbiB0byBzdG9wIHNrZWxldG9uIGxvYWRpbmcgYnkgcmVtb3ZpbmcgXCJza2VsZXRvblwiIGNsYXNzZXMgZnJvbSBncm91cFxuXG4gZnVuY3Rpb24gc2tlbGV0b25Mb2FkaW5nRW5kcygpIHtcbiAgICAvLyBncm91cGluZyBkaXZzIGJ5IGNsYXNzZXNcbiAgICBjb25zdCBhbGxMb2FkaW5nRGl2QmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNvbnRhaW5lci10b3AsIC5kaXYtcmlnaHQsIC5jb250YWluZXItYm9keSBcIilcbiAgICBjb25zdCBhbGxMb2FkaW5nRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5kaXYtbGVmdFwiKVxuXG4gICAgYWxsTG9hZGluZ0RpdkJnLmZvckVhY2goaSA9PiB7XG4gICAgICAgIGkuY2xhc3NMaXN0LnJlbW92ZShcImxvYWRpbmctZGl2LWJnXCIpXG4gICAgfSlcblxuICAgIGFsbExvYWRpbmdEaXYuZm9yRWFjaChpID0+IHtcbiAgICAgICAgaS5jbGFzc0xpc3QucmVtb3ZlKFwibG9hZGluZy1kaXZcIilcbiAgICB9KVxufVxuXG4vLyBXaWxsIGRpc2FibGUgc2tlbGV0b24gb25seSBpZiB3ZWF0aGVyIGRhdGEgYmVjb21lIGF2YWlsYWJsZVxuXG5cbi8vIERhdGEgY29udmVyc2lvblxuXG5jb25zdCB0ZW1wQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53ZWF0aGVyLXRlbXAtaW50cm8gYnV0dG9uXCIpXG5jb25zdCB0ZW1wRGVnU3ltYm9sRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53ZWF0aGVyLXRlbXAtZGl2IC50ZW1wLWRlZy1zeW1ib2xcIilcblxubGV0IGN1cnJlbnRNZXRyaWMgPSBcImludGxcIlxuXG5mdW5jdGlvbiB0b0NlbHNpdXMoZikge1xuICAgIHJldHVybiAoZiAtIDMyKSAqIDUvOVxufVxuXG5mdW5jdGlvbiB0b0ZhaHJlbmhlaXQoYykge1xuICAgIHJldHVybiAoYyAqIDkvNSkgKyAzMlxufVxuXG5mdW5jdGlvbiB0b01waChrbWgpIHtcbiAgICByZXR1cm4ga21oIC8gMS42MDlcbn1cblxuZnVuY3Rpb24gdG9LbWgobXBoKSB7XG4gICAgcmV0dXJuIG1waCAqIDEuNjA5XG59XG5cbnRlbXBCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICB0b2dnbGVNZXRyaWMoKVxufSlcblxuLy8gbGV0IHN0clRlc3QgPSBcIldpbmQ6IDEwLjggbXBoXCIgXG4vLyBjbG9nKHN0clRlc3Quc2xpY2UoNSkuc2xpY2UoMCwgLTQpKVxuXG5cbi8vIEV2ZW50IGxpc3RlbmVyc1xuXG5mdW5jdGlvbiB0b2dnbGVNZXRyaWMoKSB7XG4gICAgY29uc3QgdGVtcE51bWJlckRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIud2VhdGhlci10ZW1wLWRpdiAudGVtcC1udW1iZXJcIilcbiAgICBjb25zdCB3aW5kU3BlZWREaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLndlYXRoZXItaW5mby1kaXYgLmluZm8zXCIpXG4gICAgXG4gICAgbGV0IGRlZ051bWJlciA9IE51bWJlcih0ZW1wTnVtYmVyRGl2LnRleHRDb250ZW50KVxuICAgIGNsb2coYPCfmqggQ3VycmVudE1ldHJpYyA9ICR7Y3VycmVudE1ldHJpY31gKVxuICAgIGlmIChjdXJyZW50TWV0cmljID09PSBcInVzXCIpIHtcbiAgICAgICAgdGVtcEJ1dHRvbi50ZXh0Q29udGVudCA9IFwiwrBDXCJcbiAgICAgICAgdGVtcERlZ1N5bWJvbERpdi50ZXh0Q29udGVudCA9IFwiwrBDXCJcbiAgICAgICAgdGVtcE51bWJlckRpdi50ZXh0Q29udGVudCA9IHRvQ2Vsc2l1cyhkZWdOdW1iZXIpLnRvRml4ZWQoMClcbiAgICAgICAgbGV0IHdpbmRTcGVlZCA9IE51bWJlciggYCR7d2luZFNwZWVkRGl2LnRleHRDb250ZW50LnNsaWNlKDYpLnNsaWNlKDAsIC00KX0gYCApXG4gICAgICAgIHdpbmRTcGVlZERpdi50ZXh0Q29udGVudCA9IGBXaW5kOiAkeyB0b0ttaCh3aW5kU3BlZWQpLnRvRml4ZWQoMSkgfSBrbS9oYCBcbiAgICAgICAgY2xvZyhg8J+UlCBleHRyYWN0ZWQgd2luZFNwZWVkIG51bWJlciBpczogJHt3aW5kU3BlZWR9YCApXG4gICAgICAgIGN1cnJlbnRNZXRyaWMgPSBcImludGxcIlxuICAgICAgICBjbG9nKFwi8J+UlCBDb252ZXJ0ZWQgdG8gaW50ZXJuYXRpb25hbCBmb3JtYXQgKENlbHNpdXMgJiBrbWgpLlwiKVxuICAgIH1cbiAgICBlbHNlIGlmKGN1cnJlbnRNZXRyaWMgPT09IFwiaW50bFwiKSB7XG4gICAgICAgIHRlbXBCdXR0b24udGV4dENvbnRlbnQgPSBcIsKwRlwiXG4gICAgICAgIHRlbXBEZWdTeW1ib2xEaXYudGV4dENvbnRlbnQgPSBcIsKwRlwiXG4gICAgICAgIHRlbXBOdW1iZXJEaXYudGV4dENvbnRlbnQgPSB0b0ZhaHJlbmhlaXQoZGVnTnVtYmVyKS50b0ZpeGVkKDApXG4gICAgICAgIGxldCB3aW5kU3BlZWQgPSBOdW1iZXIoIGAke3dpbmRTcGVlZERpdi50ZXh0Q29udGVudC5zbGljZSg2KS5zbGljZSgwLCAtNSl9IGAgKVxuICAgICAgICB3aW5kU3BlZWREaXYudGV4dENvbnRlbnQgPSBgV2luZDogJHsgdG9NcGgod2luZFNwZWVkKS50b0ZpeGVkKDEpIH0gbXBoYCBcbiAgICAgICAgY3VycmVudE1ldHJpYyA9IFwidXNcIlxuICAgICAgICBjbG9nKFwi8J+UlCBDb252ZXJ0ZWQgdG8gdXMgZm9ybWF0IChGYWhyZW5oZWl0ICYgbXBoKS5cIilcbiAgICB9XG4gICAgXG59XG5cblxuY29uc3QgcG9wdWxhdGVEaXNwbGF5ID0gYXN5bmMgZnVuY3Rpb24oc2VhcmNoZWRMb2NhdGlvbiwgc2VsZWN0ZWRNZXRyaWMpe1xuICAgIGlmICghc2VhcmNoZWRMb2NhdGlvbikge1xuICAgICAgICBjbG9nKFwi8J+UlCBObyBzZWFyY2ggdGVybSBwcm92aWRlZCFcIilcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjaXR5RGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kaXYtcmlnaHQgLndlYXRoZXItdGl0bGVcIilcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25EaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRpdi1yaWdodCAud2VhdGhlci1kZXNjcmlwdGlvblwiKVxuICAgICAgICBjb25zdCBkYXRlRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kaXYtcmlnaHQgLndlYXRoZXItZGF0ZVwiKVxuICAgICAgICBjb25zdCB0ZW1wRGVnRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kaXYtbGVmdCAudGVtcC1udW1iZXJcIilcbiAgICAgICAgY29uc3QgdGVtcERlZ1N5bWJvbERpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZGl2LWxlZnQgLnRlbXAtZGVnLXN5bWJvbFwiKVxuICAgICAgICBjb25zdCB0ZW1wRGVnQnRuRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi53ZWF0aGVyLXRlbXAtaW50cm8gYnV0dG9uXCIpXG4gICAgICAgIGNvbnN0IGluZm8xRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5kaXYtbGVmdCAuaW5mbzFcIilcbiAgICAgICAgY29uc3QgaW5mbzJEaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmRpdi1sZWZ0IC5pbmZvMlwiKVxuICAgICAgICBjb25zdCBpbmZvM0RpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZGl2LWxlZnQgLmluZm8zXCIpXG4gICAgICAgIFxuICAgICAgICBsZXQgcmVzcG9uc2VEYXRhID0gYXdhaXQgd2VhdGhlclRvZGF5KHNlYXJjaGVkTG9jYXRpb24pXG5cbiAgICAgICAgY29uc3QgZ2V0V2VhdGhlckljb24gPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxldCBmaWxlTmFtZSA9IHJlc3BvbnNlRGF0YS5kYXlDb25kaXRpb25zLmljb24gXG4gICAgICAgICAgICBpZihmaWxlTmFtZSA9PT0gXCJmb2dcIiB8fCBmaWxlTmFtZSA9PT0gXCJ0aHVuZGVyXCIgKXtcbiAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGF3YWl0IGltcG9ydChgLi9pbWFnZXMvaWNvbnMvJHtmaWxlTmFtZX0ucG5nYClcbiAgICAgICAgICAgICAgICByZXR1cm4ge2ZpbGVOYW1lfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYXdhaXQgaW1wb3J0KGAuL2ltYWdlcy9pY29ucy8ke2ZpbGVOYW1lfS5zdmdgKVxuICAgICAgICAgICAgICAgIHJldHVybiB7ZmlsZU5hbWV9IH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYXdhaXQgZ2V0V2VhdGhlckljb24oKS50aGVuKG1zZyA9PiBjbG9nKG1zZy5maWxlTmFtZS5kZWZhdWx0KSlcbiAgICAgICAgY29uc3Qgd2VhdGhlckljb25EaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLndlYXRoZXItbm93LWRpdiAud2VhdGhlci1ub3ctaWNvblwiKVxuICAgICAgICBjb25zdCB3ZWF0aGVySWNvblBhdGggPSBhd2FpdCBnZXRXZWF0aGVySWNvbigpLnRoZW4obXNnID0+IG1zZy5maWxlTmFtZS5kZWZhdWx0KVxuICAgICAgICB3ZWF0aGVySWNvbkRpdi5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgYCR7d2VhdGhlckljb25QYXRofWApXG5cbiAgICAgICAgbGV0IGNpdHkgPSByZXNwb25zZURhdGEuYWRkcmVzc1xuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSByZXNwb25zZURhdGEuZGVzY3JpcHRpb25cbiAgICAgICAgbGV0IGRlZ1VzRm9ybWF0ID0gcmVzcG9uc2VEYXRhLmRheUNvbmRpdGlvbnMudGVtcC50b0ZpeGVkKDApXG4gICAgICAgIGxldCB3aW5kU3BlZWRVc0Zvcm1hdCA9IHJlc3BvbnNlRGF0YS5kYXlDb25kaXRpb25zLndpbmRzcGVlZC50b0ZpeGVkKDEpXG4gICAgICAgIGxldCBwcmVjaXBpdGF0aW9uID0gcmVzcG9uc2VEYXRhLmRheUNvbmRpdGlvbnMucHJlY2lwcHJvYlxuICAgICAgICBsZXQgaHVtaWRpdHkgPSByZXNwb25zZURhdGEuZGF5Q29uZGl0aW9ucy5odW1pZGl0eVxuICAgICAgICAvLyBDb252ZXJ0aW5nIGRhdGEgYmFzZWQgb24gdXNlciBzZXR0aW5nc1xuICAgICAgICBsZXQgdGVtcERlZ1xuICAgICAgICBsZXQgd2luZFNwZWVkXG4gICAgICAgIGlmIChjdXJyZW50TWV0cmljID09PSBcImludGxcIikge1xuICAgICAgICAgICAgY2xvZyhcIvCflJQgUHJlLWNvbnZlcnRpbmcgZGF0YSB0byBpbnRsIGZvcm1hdFwiKVxuICAgICAgICAgICAgdGVtcERlZyA9IHRvQ2Vsc2l1cyhkZWdVc0Zvcm1hdCkudG9GaXhlZCgwKVxuICAgICAgICAgICAgd2luZFNwZWVkID0gIHRvS21oKHdpbmRTcGVlZFVzRm9ybWF0KS50b0ZpeGVkKDEpXG4gICAgICAgICAgICB0ZW1wRGVnU3ltYm9sRGl2LnRleHRDb250ZW50ID0gXCLCsENcIlxuICAgICAgICAgICAgdGVtcERlZ0J0bkRpdi50ZXh0Q29udGVudCA9IFwiwrBDXCJcbiAgICAgICAgICAgIGluZm8zRGl2LnRleHRDb250ZW50ID0gYFdpbmQ6ICR7d2luZFNwZWVkfSBrbS9oYFxuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmIChjdXJyZW50TWV0cmljID09PSBcInVzXCIpIHtcbiAgICAgICAgICAgIGNsb2coXCLwn5SUIFByZS1jb252ZXJ0aW5nIGRhdGEgdG8gdXMgZm9ybWF0XCIpXG4gICAgICAgICAgICBjbG9nKGRlZ1VzRm9ybWF0KVxuICAgICAgICAgICAgdGVtcERlZyA9IGRlZ1VzRm9ybWF0XG4gICAgICAgICAgICB3aW5kU3BlZWQgPSB3aW5kU3BlZWRVc0Zvcm1hdFxuICAgICAgICAgICAgdGVtcERlZ1N5bWJvbERpdi50ZXh0Q29udGVudCA9IFwiwrBGXCJcbiAgICAgICAgICAgIHRlbXBEZWdCdG5EaXYudGV4dENvbnRlbnQgPSBcIsKwRlwiXG4gICAgICAgICAgICBpbmZvM0Rpdi50ZXh0Q29udGVudCA9IGBXaW5kOiAke3dpbmRTcGVlZH0gbXBoYFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjaXR5RGl2LnRleHRDb250ZW50ID0gY2l0eS5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgY2l0eS5zbGljZSgxKVxuICAgICAgICBkZXNjcmlwdGlvbkRpdi50ZXh0Q29udGVudCA9IGRlc2NyaXB0aW9uXG4gICAgICAgIGRhdGVEaXYudGV4dENvbnRlbnQgPSBgJHtnZXREYXlTdHJpbmcoKX0gJHtkYXRlTm93SG91cnN9OjAwYFxuICAgICAgICB0ZW1wRGVnRGl2LnRleHRDb250ZW50ID0gdGVtcERlZ1xuICAgICAgICBpbmZvMURpdi50ZXh0Q29udGVudCA9IGBQcmVjaXBpdGF0aW9uOiAke3ByZWNpcGl0YXRpb259JWBcbiAgICAgICAgaW5mbzJEaXYudGV4dENvbnRlbnQgPSBgSHVtaWRpdHk6ICR7aHVtaWRpdHl9JWAgXG4gICAgICAgIFxuICAgICAgICAvLyBEeW5hbWljIEJhY2tncm91bmQtaW1hZ2VzXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmREaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYm9keVwiKVxuICAgICAgICBsZXQgYmdJbWFnZSA9IGF3YWl0IGltcG9ydChgLi9pbWFnZXMvYmcvJHtyZXNwb25zZURhdGEuZGF5Q29uZGl0aW9ucy5pY29ufS5qcGdgKVxuICAgICAgICBjbG9nKGJnSW1hZ2UpXG4gICAgICAgIGNvbnN0IGJnSW1hZ2VGaWxlID0gYmdJbWFnZS5kZWZhdWx0XG4gICAgICAgIGJhY2tncm91bmREaXYuc3R5bGUuY3NzVGV4dCA9IGBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIke2JnSW1hZ2VGaWxlfVwiKTtgXG4gICAgICAgIGNsb2coYmFja2dyb3VuZERpdi5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UpXG5cbiAgICAgICAgLy8vIEJvdHRvbSBjYXJkc1xuXG4gICAgICAgIC8vIExvb3BpbmcgZGF5cyB1c2luZyBcImZvciAuLi4gbG9vcFwiIGJlbG93XG4gICAgICAgIC8vIFdpbGwgYmUgaW5jcmVtZW50aW5nIFwiYmFzZVwiIGRhdGUgYnkgXG4gICAgICAgIC8vIHR3ZW50eUZvdXJIb3VycyAoMjRoID0gOC42NGUrN21zKSBlYWNoIGl0ZXJhdGlvbiBcblxuICAgICAgICBsZXQgdHdlbnR5Rm91ckhvdXJzID0gMFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA4OyBpKyspIHtcbiAgICAgICAgICAgIHR3ZW50eUZvdXJIb3VycyArPSA4LjY0ZSs3XG5cbiAgICAgICAgICAgIC8vIHN1YnRyYWN0aW5nIDI0aCAoaW4gbWlsbGlzZWNvbmRzKSAoZnJvbSBcImJhc2VcIikgaGVscHMgc3RhcnRzIFxuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGZyb20gdG9kYXkncyBkYXRlXG4gICAgICAgICAgICBsZXQgYmFzZSA9IERhdGUubm93KCkgLSA4LjY0ZSs3XG5cbiAgICAgICAgICAgIC8vIE5vdyByZWFkeSB0byBzdGFydCBpbmNyZW1lbnRpbmcuXG4gICAgICAgICAgICBsZXQgY3VycmVudERhdGUgPSBiYXNlICsgdHdlbnR5Rm91ckhvdXJzXG4gICAgICAgICAgICBsZXQgY3VycmVudERhdGVEYXkgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSkuZ2V0RGF5KClcbiAgICAgICAgICAgIGNsb2coY3VycmVudERhdGVEYXkpXG4gICAgICAgICAgICAvLyBJbmRleGluZyBkaXYgZWxlbWVudCBieSBpZHMgYmFzZWQgb24gY3VycmVudCAoaSkgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IGNhcmREYXlEaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjd2VhdGhlci1jYXJkJHtpfSAuZGF5YClcbiAgICAgICAgICAgIGNvbnN0IGNhcmRJY29uRGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgI3dlYXRoZXItY2FyZCR7aX0gLmljb25gKVxuICAgICAgICAgICAgY29uc3QgY2FyZFRlbXBEaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjd2VhdGhlci1jYXJkJHtpfSAudGVtcGApXG5cbiAgICAgICAgICAgIC8vIEdpdmluZyBkYXkgdGl0bGUgJiB0ZW1wIGRhdGEgdG8gZGl2IGVsZW1lbnQgYmFzZWQgb24gXCJjdXJyZW50RGF0ZURheVwiXG4gICAgICAgICAgICAvLyBjdXJyZW50RGF0ZURheSB3aWxsIHJldHVybnMgc3VjY2Vzc2l2ZSBkYXRlIGVhY2ggaXRlcmF0aW9uKVxuICAgICAgICAgICAgLy8gRWFjaCBkYXRlIGNvcnJlc3BvbmRzIHRvIG9uZSBvZiB0aGUgNyBkYXlzIG9mIHRoZSB3ZWVrLlxuICAgICAgICAgICAgY2FyZERheURpdi50ZXh0Q29udGVudCA9IGAke2RheUFycmF5W2N1cnJlbnREYXRlRGF5XX1gXG4gICAgICAgICAgICBjYXJkVGVtcERpdi50ZXh0Q29udGVudCA9IGAke3Jlc3BvbnNlRGF0YS5kYXRhMTVEYXlzW2ktMV0udGVtcH3CsEZgXG5cbiAgICAgICAgICAgIGNvbnN0IGdldE5leHREYXlJY29uID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gcmVzcG9uc2VEYXRhLmRhdGExNURheXNbaS0xXS5pY29uIFxuICAgICAgICAgICAgICAgIGlmKGZpbGVOYW1lID09PSBcImZvZ1wiIHx8IGZpbGVOYW1lID09PSBcInRodW5kZXJcIiApe1xuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IGF3YWl0IGltcG9ydChgLi9pbWFnZXMvaWNvbnMvJHtmaWxlTmFtZX0ucG5nYClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyBcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBhd2FpdCBpbXBvcnQoYC4vaW1hZ2VzL2ljb25zLyR7ZmlsZU5hbWV9LnN2Z2ApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHREYXlJY29uUGF0aCA9IGF3YWl0IGdldE5leHREYXlJY29uKCkudGhlbihtc2cgPT4gbXNnLmRlZmF1bHQpXG4gICAgICAgICAgICBjYXJkSWNvbkRpdi5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgYCR7bmV4dERheUljb25QYXRofWAgKSBcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vLyBTZWFyY2ggZnVuY3Rpb25hbGl0aWVzXG5cbmNvbnN0IHNlYXJjaElucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxhYmVsIGlucHV0XCIpXG5jb25zdCBzZWFyY2hCdG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGFiZWwgYnV0dG9uXCIpXG5cbnNlYXJjaEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICBpZiAoc2VhcmNoSW5wdXQudmFsdWUpe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgcG9wdWxhdGVEaXNwbGF5KHNlYXJjaElucHV0LnZhbHVlKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VhcmNoSW5wdXQucmVwb3J0VmFsaWRpdHkoKVxuICAgICAgICBpZiAoIXNlYXJjaElucHV0LnZhbGlkaXR5LnZhbGlkKXtcbiAgICAgICAgICBzZWFyY2hJbnB1dC5zZXRDdXN0b21WYWxpZGl0eShcIlBsZWFzZSBlbnRlciBhIGNpdHkgdG8gZ2V0IGZvcmVjYXN0XCIpIFxuICAgICAgICB9XG4gICAgfVxufSlcblxuLy8gTG9hZGluZyBwYWdlIGJ5IGRlZmF1bHQgd2l0aCBsaXZlIHdlYXRoZXIgZGF0YVxucG9wdWxhdGVEaXNwbGF5KFwidG9reW9cIikgXG4vLyBza2VsZXRvbkxvYWRpbmdFbmRzKClcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/weather-app.js\n\n}");

/***/ })

}]);